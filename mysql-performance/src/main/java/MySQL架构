1、MySQL逻辑架构

第一层：连接器
第二层：
    查询缓存器
    解析器
    优化器
    执行器
第三层：存储引擎

对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能够命中，就不必再执行查询解析、优化和执行的整个过程，
而直接范湖查询缓存中的结果集

2、并发控制
2.1 读写锁
    共享锁  == 读锁 ：共享的，互相不阻塞，多个客户在同一时刻可以同时读取同一个资源而互不干扰
    排他锁  == 写锁 ：一个写锁会阻塞其它的写锁和读锁
2.2 锁粒度
    锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统话费大量的时间来管理锁，而不是
    存取数据，那么系统的性能可能会因此受到影响

    表锁：MySQL中开销最小的锁策略。锁定整张表，一个用户在对标进行写操作前，需要先获得写锁，这回阻塞其它用户对该表的
    所有读写操作。只有没写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的。
    行级锁：可以最大程度支持并发处理，同时也带来了最大的锁开销。

    表锁在存储引擎层、Mysql的服务器层有实现。
    行级锁只在存储引擎层实现，在Mysql的服务器层没有实现。

3、事务
    ACID特性
    隔离级别
        读未提交
        读已提交
        可重复读
        串行化
    脏读、不可重复读、幻读、加锁读
    Mysql中的事务：
        自动提交：
            如果不显式的开始一个事物，则每个查询都被当做一个事物执行提交操作。
            通过设置变量AUTOCOMMIT启用/禁用自动提交，查看SHOW VARIABLES LIKE 'AUTOCOMMIT'

4、多版本并发控制（MVCC）
    MTySQL、Oracle均实现了MVCC，不同的存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。【Q:悲观和乐观灭有体现出来？】

    InnoDB的MVCC:通过在每行记录后面保存两个隐藏的列来实现的，保存的是【系统版本号】。
                 每开始一个新的事务，【系统版本号】都会自动递增。
                 事务开始时刻的系统版本号会最为【事务的版本号】，用来和查询到的每行记录的版本号进行比较。
        select:
            a.只查找行版本号小于或等于事务版本号
            b.行的删除版本号要么未定义，要多大于当前事务版本号。【Q:什么时候回出现大于当前事务版本号的情况？】
            符合上述两个调教的记录，才能返回作为查询结果。
        insert:为新插入的每一行保存当前系统版本号作为行版本号
        delete:为删除的每一行保存当前系统版本号作为行删除标志
        update:微信插入的一行，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标志

    保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。不足之处在于需要额外的存储空间，需要做更多的航检查工作，以及一些额外的维护工作。
